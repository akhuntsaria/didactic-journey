package main

import (
	"errors"
	"fmt"
	"net"
	"os"
	"strings"
)

type RespGen func() string

var (
	CONN_PREFACE        = []byte("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n")
	FRAME_TYPE_SETTINGS = 0x4
)

var paths = make(map[string]RespGen)

func Get(path string, fn RespGen) {
	paths[path] = fn
}

func bytesStartWith(src []byte, search []byte) bool {
	if len(src) < len(search) {
		return false
	}

	for i := range search {
		if src[i] != search[i] {
			return false
		}
	}

	return true
}

// [0x00, 0xff, 0x01] -> 65281
func bytesToDec(bin []byte) int {
	dec := 0
	for i := 0; i < len(bin); i++ {
		dec |= int(bin[i]) << (8 * (len(bin) - i - 1))
	}
	return dec
}

// 65281, 2 -> [0xff, 0x01]
func decToBytes(dec int, len int) []byte {
	bytes := make([]byte, len)
	for i := 0; i < len; i++ {
		bytes[i] = byte(dec >> (8 * (len - i - 1)))
	}
	return bytes
}

func generateFrame(frameType byte, flags byte, streamId []byte, payload []byte) []byte {
	frame := []byte{}

	payloadLen := decToBytes(len(payload), 3)
	frame = append(frame, payloadLen...)

	frame = append(frame, frameType, flags)
	frame = append(frame, streamId...)
	frame = append(frame, payload...)
	return frame
}

func handleConn(conn net.Conn) {
	defer conn.Close()
	fmt.Println("Accepted connection from", conn.RemoteAddr())

	buff := make([]byte, 1024)
	http2 := false
	settingsSent := false
	for {
		n, err := conn.Read(buff)
		if err != nil {
			if err.Error() != "EOF" {
				fmt.Printf("Error reading from %s: %s\n", conn.RemoteAddr(), err.Error())
			}
			break
		}

		if http2 {
			fmt.Printf("Received %d bytes from %s: %s", n, conn.RemoteAddr(), buff[:n])
			err := parseHttp2(buff)
			if err != nil {
				break
			}
			if !settingsSent {
				writeConnBytes(conn, buff[len(CONN_PREFACE):n])
				settingsSent = true
			} else {
				writeConnBytes(conn, buff[:n])
				headersAndData := []byte{0x00, 0x00, 0x2a, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x3f, 0xe1, 0x1f, 0x8d, 0x76, 0x8b, 0xca, 0x54, 0xa7, 0xd7, 0xf4, 0x11, 0x2e, 0x05, 0xdc, 0xfe, 0xff, 0x5f, 0x91, 0x49, 0x7c, 0xa5, 0x89, 0xd3, 0x4d, 0x1f, 0x64, 0x9c, 0x76, 0x20, 0xa9, 0x82, 0xd4, 0xca, 0xb3, 0xdf, 0x0f, 0x0d, 0x83, 0x75, 0xb6, 0x7f, 0x00, 0x02, 0xf1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x3c, 0x21, 0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x20, 0x6c, 0x61, 0x6e, 0x67, 0x3d, 0x22, 0x65, 0x6e, 0x22, 0x3e, 0x0a, 0x3c, 0x68, 0x65, 0x61, 0x64, 0x3e, 0x0a, 0x3c, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x3e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x34, 0x30, 0x34, 0x20, 0x2d, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x3e, 0x0a, 0x3c, 0x6d, 0x65, 0x74, 0x61, 0x20, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x22, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x22, 0x3e, 0x0a, 0x3c, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x3e, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x7b, 0x20, 0x66, 0x6f, 0x6e, 0x74, 0x2d, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x3a, 0x20, 0x73, 0x61, 0x6e, 0x73, 0x2d, 0x73, 0x65, 0x72, 0x69, 0x66, 0x3b, 0x20, 0x7d, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x74, 0x64, 0x20, 0x7b, 0x20, 0x62, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x3a, 0x20, 0x31, 0x70, 0x78, 0x20, 0x73, 0x6f, 0x6c, 0x69, 0x64, 0x20, 0x23, 0x33, 0x33, 0x33, 0x3b, 0x20, 0x7d, 0x20, 0x74, 0x64, 0x2c, 0x20, 0x74, 0x68, 0x20, 0x7b, 0x20, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x3a, 0x20, 0x35, 0x70, 0x78, 0x3b, 0x20, 0x7d, 0x20, 0x74, 0x68, 0x65, 0x61, 0x64, 0x2c, 0x20, 0x74, 0x66, 0x6f, 0x6f, 0x74, 0x20, 0x7b, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x2d, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x3a, 0x20, 0x23, 0x33, 0x33, 0x33, 0x3b, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x3a, 0x20, 0x23, 0x66, 0x66, 0x66, 0x3b, 0x20, 0x7d, 0x20, 0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x3e, 0x0a, 0x3c, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x3e, 0x0a, 0x3c, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x68, 0x32, 0x3e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x34, 0x30, 0x34, 0x20, 0x2d, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x2e, 0x3c, 0x2f, 0x68, 0x32, 0x3e, 0x0a, 0x3c, 0x70, 0x3e, 0x4e, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x3c, 0x2f, 0x70, 0x3e, 0x0a, 0x3c, 0x70, 0x3e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x73, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x61, 0x72, 0x65, 0x3a, 0x3c, 0x2f, 0x70, 0x3e, 0x0a, 0x3c, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x3d, 0x22, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x73, 0x22, 0x3e, 0x3c, 0x74, 0x68, 0x65, 0x61, 0x64, 0x3e, 0x3c, 0x74, 0x72, 0x3e, 0x3c, 0x74, 0x68, 0x3e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x50, 0x61, 0x74, 0x68, 0x3c, 0x2f, 0x74, 0x68, 0x3e, 0x3c, 0x74, 0x68, 0x3e, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x3c, 0x2f, 0x74, 0x68, 0x3e, 0x3c, 0x74, 0x68, 0x3e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3c, 0x2f, 0x74, 0x68, 0x3e, 0x3c, 0x74, 0x68, 0x3e, 0x4c, 0x69, 0x66, 0x65, 0x43, 0x79, 0x63, 0x6c, 0x65, 0x3c, 0x2f, 0x74, 0x68, 0x3e, 0x3c, 0x2f, 0x74, 0x72, 0x3e, 0x3c, 0x2f, 0x74, 0x68, 0x65, 0x61, 0x64, 0x3e, 0x3c, 0x74, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x74, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x3c, 0x2f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x3e, 0x3c, 0x68, 0x72, 0x2f, 0x3e, 0x0a, 0x3c, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x65, 0x63, 0x6c, 0x69, 0x70, 0x73, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x6a, 0x65, 0x74, 0x74, 0x79, 0x22, 0x3e, 0x3c, 0x69, 0x6d, 0x67, 0x20, 0x61, 0x6c, 0x74, 0x3d, 0x22, 0x69, 0x63, 0x6f, 0x6e, 0x22, 0x20, 0x73, 0x72, 0x63, 0x3d, 0x22, 0x2f, 0x66, 0x61, 0x76, 0x69, 0x63, 0x6f, 0x6e, 0x2e, 0x69, 0x63, 0x6f, 0x22, 0x2f, 0x3e, 0x3c, 0x2f, 0x61, 0x3e, 0x26, 0x6e, 0x62, 0x73, 0x70, 0x3b, 0x3c, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x65, 0x63, 0x6c, 0x69, 0x70, 0x73, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x6a, 0x65, 0x74, 0x74, 0x79, 0x22, 0x3e, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x45, 0x63, 0x6c, 0x69, 0x70, 0x73, 0x65, 0x20, 0x4a, 0x65, 0x74, 0x74, 0x79, 0x3a, 0x2f, 0x2f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3c, 0x2f, 0x61, 0x3e, 0x3c, 0x68, 0x72, 0x2f, 0x3e, 0x0a, 0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a}
				writeConnBytes(conn, headersAndData)
			}
			continue
		}

		msg := string(buff[:n])
		fmt.Printf("Received %d bytes from %s: %s", n, conn.RemoteAddr(), msg)

		// Leave only headers
		msg = msg[:strings.Index(msg, "\r\n\r\n")]

		lines := strings.Split(strings.TrimSpace(msg), "\r\n")
		responded := false
		for _, a := range lines {
			if a == "Upgrade: h2c" {
				msg = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: h2c\r\nConnection: Upgrade\r\n\r\n"
				if !writeConn(conn, msg) {
					break
				}
				http2 = true
				responded = true
				break
			}
		}

		if responded {
			continue
		}

		if len(lines) != 0 {
			firstLine := strings.TrimSpace(lines[0])
			parts := strings.Split(firstLine, " ")
			path := parts[1]
			if fn, ok := paths[path]; ok {
				response := fn()
				msg = fmt.Sprintf("HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n%s", len(response), response)

				if !writeConn(conn, msg) {
					break
				} else {
					responded = true
				}
			}
		}

		if !responded {
			msg = "HTTP/1.1 400 Bad Request\r\nContent-Length: 0\r\n\r\n"
			if !writeConn(conn, msg) {
				break
			}
		}
	}

	fmt.Println("Closed connection from", conn.RemoteAddr())
}

func parseHttp2(buff []byte) error {
	if len(buff) == 0 {
		return errors.New("empty message")
	}

	cur := 0

	if bytesStartWith(buff, CONN_PREFACE) {
		// Ignore the preface, set cursor after it
		cur = len(CONN_PREFACE)
	}

	payloadSize := bytesToDec(buff[cur : cur+3])
	cur += 3

	frameType := buff[cur]
	cur++

	flags := buff[cur]
	cur++

	streamId := bytesToDec(buff[cur : cur+4])
	cur += 4

	payload := buff[cur : cur+payloadSize]

	fmt.Println("FRAME:", payloadSize, frameType, flags, streamId, payload)
	return nil
}

func writeConn(conn net.Conn, msg string) bool {
	fmt.Printf("Writing to %s: %s\n", conn.RemoteAddr(), msg)

	_, err := conn.Write([]byte(msg))
	if err != nil {
		fmt.Printf("Error writing to %s: %s\n", conn.RemoteAddr(), err.Error())
		return false
	}

	return true
}

func writeConnBytes(conn net.Conn, msg []byte) bool {
	fmt.Printf("Writing %d bytes to %s: %s\n", len(msg), conn.RemoteAddr(), msg)

	_, err := conn.Write(msg)
	if err != nil {
		fmt.Printf("Error writing to %s: %s\n", conn.RemoteAddr(), err.Error())
		return false
	}

	return true
}

func Start() {
	listener, err := net.Listen("tcp", ":80")
	if err != nil {
		fmt.Println("Error listening on port 80:", err.Error())
		os.Exit(1)
	}

	fmt.Println("Waiting for connections on port 80")

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("Error accepting connection on port 80:", err.Error())
			continue
		}

		go handleConn(conn)
	}

}
